---
title: 适配器模式(Adapter Pattern)
tags:
  - Design Pattern
categories:
  - Development
  - Design Pattern
toc: true
cover: /assets/images/design-patterns/design-pattern.jpg
abbrlink: b8ab8ad6
date: '2024-08-19 16:42:43'
---

使用适配器模式的类图如下：

<!-- more -->
{% plantuml %}
class Main
interface Print {
	+ printWeak()
	+ printStrong()
}

class PrintBanner extends Banner implements Print {
	+ banner
	+ printWeak()
	+ printStrong()
}

class Banner {
	+ showWithParen()
	+ showWithAster()
}

Main -down-> Print: Uses >
{% endplantuml %}

适配器模式有两种方式实现。

1. 使用继承

使用继承来实现时，`client`调用的的`Target`其实是一个接口,这个接口被一个适配器实现,而适配器又继承了被适配对象,如下图:

{% plantuml %}
class Client

interface Target <<Interface>>
class Adapter
class Adaptee

Client -down-> Target : Uses >
Target <|.right. Adapter: < implements
Adapter -right-|> Adaptee: > extends
{% endplantuml %}

2. 使用委托

    使用委托的时候,所有的参与者都是对象,具体如下图:

{% plantuml %}
class Client

class Target
class Adapter
class Adaptee

Client -down-> Target : Uses >
Target <|.right. Adapter: < extends
Adapter o-right-> Adaptee: > has
{% endplantuml %}

`Adaptee`作为`Adapter`的成员存在.在调用过程中, 直接可以将对`Adaptee`的操作,委托给`Adapter`来执行. 可以用于封装一些操作,也可以进行解耦.



一个比较直观的例子就是:

> 假设有一个旧的电视机，它只有一个RCA接口（一个老式的模拟信号接口），而你有一个新的游戏控制器，它使用HDMI接口（一个现代的数字信号接口）。两者之间无法直接连接，因为它们使用不同的接口。在这种情况下，你需要一个HDMI到RCA的适配器。

在上面的例子中, `Client`就是你,你需要操作一个`RCA`接口,但是这个接口你无法直接使用,因为你只有一个`HDMI`接口的设备,这时候, `Adaptee`就是`HDMI`接口, `Target`是`RCA`接口, 你需要一个`HDMI`转`RCA`的适配器(`Adapter`), 这样就可以将所有对`RCA`的操作,委托给适配器来操作,而作为使用者,只需要知道`HDMI`的操作方式即可.

# Conclusion

适配器模式主要分为两种：

1. **类适配器模式**：使用多重继承对一个接口与另一个接口进行匹配。类适配器通过继承来实现适配器功能。
2. **对象适配器模式**：使用组合来连接不兼容的接口。对象适配器基于组合，即适配器包含了被适配者的实例。

适配器模式通常包含以下角色：

* **目标（Target）** ：目标是客户端所期望的接口，它定义了客户端需要使用的特定领域的接口。
* **需要适配的类（Adaptee）** ：需要适配的类是一个已经存在的类，它提供了一些有用的行为，但其接口与目标接口不兼容。
* **适配器（Adapter）** ：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配。适配器实现了目标接口，并包含了一个需要适配的类的引用。

使用适配器模式的好处:

1. 可以尽量复用已经写好的,经过测试的代码,从而减少bug的出现
2. 可以对版本或者不同的feature变动进行平滑的过度.
3. 可以在不改变现有代码的情况下,添加新的功能.

使用适配器模式中需要注意的:

1. 在功能完全不能匹配的时候,适配器模式是不能正常工作的:

    比如: 让一个电源插座,流出自来水.

# 相关的模式:

桥接(Bridge)模式

|特性/模式|((20240612123452-n5du1an '适配器（Adapter）模式'))|桥接模式(Bridge Pattern)|
| -----------| ---------------------------------------------------------------------------------------------------------------| ------------------------------------------------------|
|**目的**|解决接口不兼容的问题。|将抽象部分与实现部分分离，使它们可以独立变化。|
|**关注点**|如何将一个类的接口转换成另一个接口。|如何将抽象与实现解耦，以便于它们可以独立扩展。|
|**使用场景**|当需要使用一个已有的类，但接口不符合需求。|当一个类存在多种实现，并且希望这些实现可以独立变化。|
|**实现方式**|通过创建一个中间层来适配不同的接口。|通过定义抽象部分和实现部分，使它们可以独立变化。|
|**主要角色**|目标、适配者、适配器。|抽象化、实现化、具体化。|
|**优点**|- 增加类的复用性。- 允许不同接口的设计协同工作。|- 降低抽象和实现之间的耦合度。- 系统更易于扩展。|
|**缺点**|- 可能会增加系统的复杂性。|- 需要为每种实现创建一个独立的类。|
|**关系**|两种模式可以独立使用，解决不同的设计问题。<br />可以组合使用，以解决更复杂的设计问题。||

假设我们有一个系统，它需要与多种打印机进行通信，并且打印机的实现可能会变化（比如增加新的打印技术）。我们可以这样设计：

1. **使用适配器模式**：为每种打印机创建一个适配器，以适配系统的打印接口。
2. **使用桥接模式**：定义一个抽象的打印机类，以及一个或多个实现类，这些实现类可以独立于抽象类进行扩展。

这样，系统就可以通过适配器与不同的打印机进行通信，同时打印机的实现也可以独立于抽象类进行变化，满足桥接模式的设计要求。



装饰器(Decorator)模式

|特性/模式|适配器模式 (Adapter Pattern)|装饰器模式 (Decorator Pattern)|
| -----------| -----------------------------------------------------------------------------------------------------------| --------------------------------------------------|
|**目的**|使不兼容的接口能够一起工作。|动态地给对象添加额外的职责。|
|**关注点**|接口转换。|对象职责的扩展。|
|**使用场景**|需要使用接口不兼容的类。|需要动态地扩展对象的功能。|
|**实现方式**|通过创建一个中间层来适配接口。|通过创建包装对象来添加职责。|
|**主要角色**|目标接口、适配者、适配器。|抽象组件、具体组件、装饰器。|
|**优点**|- 增加类的复用性。- 允许不同接口的设计协同工作。|- 增加对象的灵活性。- 避免使用继承带来的复杂性。|
|**缺点**|- 可能会增加系统的复杂性。|- 可能会创建过多的小对象。|
|**关系**|两种模式可以独立使用，解决不同的问题。<br />可以组合使用，以解决更复杂的设计问题。||
 
